<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Lab 6 | Liam Kain - ECE-4160</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Lab 6" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is the documentation for what I have completed in ECE-4160" />
<meta property="og:description" content="This is the documentation for what I have completed in ECE-4160" />
<link rel="canonical" href="http://localhost:4000/Lab_6/" />
<meta property="og:url" content="http://localhost:4000/Lab_6/" />
<meta property="og:site_name" content="Liam Kain - ECE-4160" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Lab 6" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"This is the documentation for what I have completed in ECE-4160","headline":"Lab 6","url":"http://localhost:4000/Lab_6/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Liam Kain - ECE-4160" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Liam Kain - ECE-4160</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/Lab_1/">Lab 1</a><a class="page-link" href="/Lab_2/">Lab 2</a><a class="page-link" href="/Lab_3/">Lab 3</a><a class="page-link" href="/Lab_4/">Lab 4</a><a class="page-link" href="/Lab_5/">Lab 5</a><a class="page-link" href="/Lab_6/">Lab 6</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Lab 6</h1>
  </header>

  <div class="post-content">
    <p>In this lab, PID control was implemented on the artemis in order to simulate the simplest control using one of the sensors on the robot.</p>

<h2 id="prelab">Prelab</h2>
<h3 id="clearly-describe-how-you-handle-sending-and-receiving-data-over-bluetooth">Clearly describe how you handle sending and receiving data over Bluetooth</h3>
<p>To send and receive data, I simply used the GET_AGMT_5s command from the last labs which would send IMU and TOF sensor data over bluetooth.
I used 7 arrays</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int timeBuff[BUF_SIZE];
float yawBuff[BUF_SIZE];
float rollBuff[BUF_SIZE];
float pitchBuff[BUF_SIZE];
int16_t motorBuff[BUF_SIZE];
int16_t dist1Buff[BUF_SIZE];
int16_t dist2Buff[BUF_SIZE];
</code></pre></div></div>

<p>When the sensors have data ready the data is stored like this</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                timeBuff[cnt] = (int)millis();
                yawBuff[cnt] = yaw_g;
                rollBuff[cnt] = roll_c;
                pitchBuff[cnt] = pitch_c;
#if TOF1 == 1
                getDistance(&amp;vl53_1, &amp;(dist1Buff[cnt]));
#endif
                // new measurement for the taking!

#if TOF2 == 1
                getDistance(&amp;vl53_2, &amp;(dist2Buff[cnt]));
#endif
                doPID(dist1Buff[cnt], (int16_t)fun_arg, motorBuff, cnt);
                cnt++;
</code></pre></div></div>

<p>This occurs in a time loop, so every time data is ready, sensor data is stored in an array and time stamped.
This also shows that the PID loop occurs every time sensor data is ready since in between data collections, doPID isn’t helpful.</p>

<p>At the end of the timed loop, the arrays are sent in the same manner as previous labs to the host computer. In python, as explained in Lab 4, this data is
read into a dictionary of arrays. The only change was the addition of</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    appendVal(data["motor"],arr,'M',0)
</code></pre></div></div>

<p>This allowed pwm values to be received. These motor values are assigned in the ‘doPID’ function explained later.</p>

<h2 id="lab-tasks">Lab Tasks</h2>

<h3 id="rangespeedsampling-time">Range/Speed/Sampling time</h3>

<p>For consistency with future labs, I collected all sensor data at once. By measuring the time between measurements, I got
an average sampling period of about 95ms. This is a sampling frequency of around 10Hz, so the loop can only execute as quickly as 10Hz. In the future, I may split these measurements up to increase the sampling rate of
the IMU measurements. From Lab 3, the range of the TOF sensor is about 4m, so the error from the TOF sensor can be at most 4000mm. I also had to find the maximum speed of the robot. To find this, I looked at one of the trials and took the slope of these two points.</p>

<p><img src="../images/deriv.png" alt="Italian Trulli" width="100%" /></p>

<p>resulting in a calculated speed of 2.317m/s. This is very much on the high end as trials starting closer to the wall were well under 1m/s.
The deadband was also found from last lab to be a pwm value of 24, so that had to be taken into account.</p>

<h3 id="coefficient-choice">Coefficient choice</h3>
<p>The first coefficient to workout was Kp. Since proportional control is simply multiplying by the error to approximate a pwm value, then
\(\text{maximum pwm value} = (\text{maximum error}) * K_P\)
so,
\(K_P \approx \frac{\text{maximum pwm value}}{\text{maximum error}} = \frac{4000mm}{255} \approx .06\)
so Kp should be of that magnitude.
At the end of adjusting values, Kp was settled at 0.08 which was around what was expected.
For Ki, this value would be multiplied by the integrated value which would increase every sampling period which is later discussed as around 100ms,
so if Ki is to have the same values of Kp, then
\(Ki = \frac{K_P}{10Hz} = 0.006\)
After testing though, Ki became much higher at 0.15.
To keep the integral from getting too large, I had to clamp the error accumulator. Since the robot starts so far from the equilibrium point, I didn’t want error to accumulate too much, so I clamped the error accumulator at about 300mm to be easy to turn over near equilibrium.</p>

<p>To find Kd, Kd would be the change in error and thus the derivative of position, so since the speed of the robot is at maximum,
2.317m/s, then
\(K_D \approx \frac{maximum pwm}{maximum change in error} = \frac{maximum pwm}{\frac{maximum speed}{sampling time}} = \frac{(255)(.1s)}{2.317m/s} \approx 11\)
This number is gigantic, but Kd should have a much smaller effect than Kp, so Kd was estimated to be around 100th of the size at around .2</p>

<h3 id="creating-system">Creating system</h3>
<p>To create the PID controller, the doPID method shown earlier simply adjusts the pwm value of the motors according to the TOF data using the methods from lab 5. Here is the code for the controller,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (current_pos == -1)
    current_pos = 0;
int16_t error = current_pos - desired_pos;


error_accumulation += error;

if (error_accumulation &gt; Imax)
    error_accumulation = Imax;
if (error_accumulation &lt; (-Imax))
    error_accumulation = -Imax;
int16_t error_deriv = error - prev_error;
int16_t duty1 = Kp * error;
int16_t duty2 = Ki * error_accumulation;
int16_t duty3 = Kd * error_deriv;
int16_t duty_cycle = duty1 + duty2 + duty3;
prev_error = error;
if (duty_cycle &lt; -1)
    duty_cycle -= min_threshold;
else if (duty_cycle &gt; 1)
    duty_cycle += min_threshold;
if (duty_cycle &gt; 255)
    duty_cycle = 255;
if (duty_cycle &lt; -255)
    duty_cycle = -255;
change_speed((int)duty_cycle, (int)duty_cycle);
motorBuff[cnt] = duty_cycle;
</code></pre></div></div>

<p>Here, I use the deadband value, ‘min_threshold’, to make sure the pwm values can move the robot at minimum. I also clamp
the accumulator value in order to make sure the error can change sign easily.</p>

<p>I had to figure out if I needed to take care of integral windup, the integral accumulator takes care of any windup.
I also had to take care of derivative kick, but since my error derivative was continuous due to a constant setpoint, this was not needed.
My error also changed very slowly, so a low pass filter was not needed either as all data frequencies were low from the TOF sensor.</p>

<p>I created a useful command, “CHANGE_PID” to change my pid values as well as integrator clamp and deadband over bluetooth like this</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    success = robot_cmd.get_next_value(P);
    if (!success)
        return;
    success = robot_cmd.get_next_value(I);
    if (!success)
        return;
    success = robot_cmd.get_next_value(D);
    if (!success)
        return;
    success = robot_cmd.get_next_value(min);
    if (!success)
        return;
    success = robot_cmd.get_next_value(max);
    if (!success)
        return;
    Kp = P;
    Ki = I;
    Kd = D;
    min_threshold = (int16_t)min;
    Imax = (int16_t)max;
</code></pre></div></div>

<p>and called like this 
    ble.send_command(CMD.CHANGE_PID,”|.08|.02|.35|35|200”)</p>

<p>This function testing PID values very easy.</p>

<p>To find all values, I used the 2nd heuristic approach discussed in lecture. First I increased Kp from about 0.001
until the car overshot the 300mm mark. I settled on about 0.008 shown by this video.</p>

<video width="100%" controls="">
  <source src="../videos/p.webm" type="video/webm" />
  Your browser does not support the video tag.
</video>

<p>I then decreased Kp to 0.004 and increased Ki until it lost stability shown here at about 0.03</p>

<video width="100%" controls="">
  <source src="../videos/pi.webm" type="video/webm" />
  Your browser does not support the video tag.
</video>

<p>Finally, I decreased Ki to about 0.2 and increased Kd until the system had steady control to a value of 0.2 resulting in these videos</p>

<h3 id="trial-1">trial 1</h3>
<video width="100%" controls="">
  <source src="../videos/trial1.webm" type="video/webm" />
  Your browser does not support the video tag.
</video>

<h3 id="trial-2">trial 2</h3>
<video width="100%" controls="">
  <source src="../videos/trial2.webm" type="video/webm" />
  Your browser does not support the video tag.
</video>

<h3 id="trial-3">trial 3</h3>
<video width="100%" controls="">
  <source src="../videos/trial3.webm" type="video/webm" />
  Your browser does not support the video tag.
</video>

<p>Here is the data for trial 3</p>

<p><img src="../images/trial_3_distance.png" alt="Italian Trulli" width="100%" /></p>

<p><img src="../images/trial_3_motor.png" alt="Italian Trulli" width="100%" />
There’s one flaw in all of these trials, equilibrium is not fully reached. I realized in my code that I needed to change my
deadband calculation to</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (duty_cycle &lt;= -1)
    duty_cycle -= min_threshold;
else if (duty_cycle =&gt; 1)
    duty_cycle += min_threshold;
</code></pre></div></div>

<p>As small PID calculations of 1 and -1 wouldn’t move the robot. I increased Ki and Kd significantly as Ki got the robot to move towards the wall much faster 
and Kd was able to prevent large overshoot thus resulting in the optimal system shown in an extra trial</p>

<h3 id="trial-4">trial 4</h3>

<video width="100%" controls="">
  <source src="../videos/trial4.webm" type="video/webm" />
  Your browser does not support the video tag.
</video>

<p><img src="../images/trial_4_distance.png" alt="Italian Trulli" width="100%" /></p>

<p><img src="../images/trial_4_motor.png" alt="Italian Trulli" width="100%" /></p>

<p>As can be seen, the system is quickly able to reach equilibrium without overshoot very much.</p>

<p>One problem seen in the video is that the car turns when it stops. This is due to the unequal powers of each motor, so when the motors start to slow down, they
slow down at a different rate thus causing the car to turn. I may have to find a different way to make sure the motors move at the same speed instead
of using a constant multiplier.</p>

  </div>

</article>

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Liam Kain - ECE-4160</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Liam Kain - ECE-4160</li><li><a class="u-email" href="mailto:ljk74@cornell.edu">ljk74@cornell.edu</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/lk1007"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">lk1007</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is the documentation for what I have completed in ECE-4160</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
